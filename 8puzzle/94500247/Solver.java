/* *****************************************************************************
 *  Name:    Ella Grady
 *  NetID:   aturing
 *  Precept: P00
 *
 *
 *  Description: implements A* search to solve n-by-n slider puzzles.
 *      Has instance variables minPq searchNodes, initial board, goalBoard, and
 *      int size of board. The private comparable SearchNode class creates
 *      a comparable for the searchNodes to be used with the minpq searchNodes
 *      where it compares the priorities (the sum of the number of moves and
 *      manhattan distance for a board) of two boards. The constructor finds solutions
 *      to the initial given board. moves(0 returns the minimum number of moves
 *      to solve the initial board, and solution() returns the sequence of boards in
 *      the shortest possible solution.
 *
 **************************************************************************** */

import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.Stopwatch;

public class Solver {
    private MinPQ<SearchNode> searchNodes; // min pq instance variable
    private Board initial; // instance of initial board
    private Board goalBoard; // instance of goal board
    private int size; // size of board

    // comparable class for search node
    private class SearchNode implements Comparable<SearchNode> {
        private Board board; // instance of board
        private int moves; // number of moves
        private int priority; // priority for a board
        // private int manhattanpriority;
        // private int hammingPriority;
        private SearchNode previousNode; // previous node

        // constructor for searchnode comparable
        public SearchNode(Board board, int moves, SearchNode previousNode) {
            this.board = board; // board is equal to input board
            this.moves = moves; // move equal to given moves
            // priority equals the manhattan distance of board + moves
            priority = moves + this.board.manhattan();
            // manhattanpriority = moves + this.board.manhattan();
            // hammingPriority = moves + this.board.hamming();
            this.previousNode = previousNode; // previous node equals given
        }

        // compares two search node objects
        public int compareTo(SearchNode that) {
            // difference between the priorities
            return (this.priority - that.priority);
        }
    }

    // find a solution to the initial board (using the A* algorithm)
    public Solver(Board initial) {
        // if input is null throw exception
        if (initial == null) {
            throw new IllegalArgumentException();
        }
        // instance initial board equals input
        this.initial = initial;
        // size equals size of input board
        size = initial.size();
        // makes search nodes a minpq of searchnode
        searchNodes = new MinPQ<SearchNode>();

        // creates goal board
        int[][] goal = new int[size][size];
        int k = 1;
        for (int i = 0; i < size; i++)
            for (int j = 0; j < size; j++) {
                goal[i][j] = k;
                k++;
            }
        goal[size - 1][size - 1] = 0;
        goalBoard = new Board(goal);

        SearchNode minimum; // holder for the smallest key in searchnodes
        // inserts new search node comparble for initial board
        searchNodes.insert(new SearchNode(this.initial, 0, null));
        // while the board with the smallest priority is not the goalboard
        while (!searchNodes.min().board.equals(goalBoard)) {
            // if the initial board is solvable break the loop
            if (!this.initial.isSolvable()) {
                break;
            }
            // sets minimum equal to the smallst priority in searchnodes
            minimum = searchNodes.min();
            // removes the smallest priority from searchnodes
            searchNodes.delMin();
            // checks each neighbor generated by neighbors
            for (Board neighbor : minimum.board.neighbors()) {
                // if the moves is equal to 0 insert that neighbor into searchNode with moves+1
                if (minimum.moves == 0) {
                    searchNodes.insert(new SearchNode(neighbor, minimum.moves + 1, minimum));
                }
                // if the neighbor is equal to a previous board do not insert into searchNode
                else if (!neighbor.equals(minimum.previousNode.board)) {
                    searchNodes.insert(new SearchNode(neighbor, minimum.moves + 1, minimum));
                }
            }
        }

    }


    // min number of moves to solve initial board
    public int moves() {
        // if the board isn't solvable throw exception
        if (!initial.isSolvable()) {
            throw new IllegalArgumentException();
        }
        // return number of moves
        return searchNodes.min().moves;
    }

    /* //  for readme testing
    public int manhattanpriority() {

        // if the board isn't solvable throw exception
        if (!initial.isSolvable()) {
            throw new IllegalArgumentException();
        }
        // return number of moves
        return searchNodes.min().manhattanpriority;
    }

    public int hammingpriority() {
        // if the board isn't solvable throw exception
        if (!initial.isSolvable()) {
            throw new IllegalArgumentException();
        }
        // return number of moves
        return searchNodes.min().hammingPriority;
    } */

    // sequence of boards in a shortest solution
    public Iterable<Board> solution() {
        // if board not solvable throw exception
        if (!initial.isSolvable()) {
            throw new IllegalArgumentException();
        }
        // stack of solution boards
        Stack<Board> solution = new Stack<Board>();
        // search node current equals the board with the smallest priority
        SearchNode current = searchNodes.min();
        // while the current node has parent nodes
        while (current.previousNode != null) {
            // add the current board to the solutions
            solution.push(current.board);
            // set the current board to the parent board
            current = current.previousNode;
        }
        // push the initial board to the stack
        solution.push(initial);
        // return the full stack of solutions
        return solution;
    }

    // test client (see below)
    public static void main(String[] args) {

        In in = new In(args[0]);
        int n = in.readInt();

        int[][] boardArray = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                boardArray[i][j] = in.readInt();
            }
        }
        Board initial = new Board(boardArray);
        StdOut.println(initial);

        // solve the puzzle
        Stopwatch timer = new Stopwatch();
        Solver solver = new Solver(initial);

        // print solution to standard output
        if (!solver.initial.isSolvable())
            StdOut.println("Unsolvable puzzle");
        else {
            StdOut.println("Minimum number of moves = " + solver.moves());
            for (Board board : solver.solution()) {
                StdOut.println(board);
            }
        }
        double time = timer.elapsedTime();
        StdOut.println("time: " + time);

    }

}
